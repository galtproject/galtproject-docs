# ClaimManager

## Цель контракта

* Дать участникам возможность подать претензию на рассмотрение гуппе присяжных и получить
 компенсацию в случае положительного решения. Компенсация производится за счет депозитов
 валидаторов.

## Роли заявки
Роли валидаторов, используемые в заявках, жестко прописан в контракте ClaimManager.
Список ролей в контракте Validators, который задается вручную, должен четко ему соответствовать

* `CM_JUROR` - Валидатор жюри

## Содержание заявки
* ID токена упаковки
* Список хешей прилагаемых документов из IPFS

## Статусы заявок
* `SUBMITTED` - новая заявка, сразу после создания готова к рассмотрению валидаторами
* `APPROVED` - подтверждена
* `REVERTED` - возвращена на доработку
* `REJECTED` - отклонена

## Статусы ролей
* `PENDING` - ожидает блокировки валидатором с данной ролью
* `LOCKED` - заблокирована валидатором с данной ролью

## Действия
* `APPROVE` - одобрить
* `REJECT` - отклонить
* `REVERT` - вернуть на доработку

![Claim Status List](https://docs.google.com/drawings/d/e/2PACX-1vSvuQiIwxnd6bA2FOFohsspQFeDyR_Y004r7zFwHd9EZDDp4mtzlqUuFC9xv9i2eG8ir2uc4ECU0wA9/pub?w=600&h=683 "Claim Status List")

## Интерфейс для владельца контракта

#### setNofM()
Владелец контракта устанавливает минимальные значения для:
- N - требуемое количество голосов `за`
- M - требуемое количество валидаторов для голосования, которые могут назначится на претензию

#### #claimGaltSpaceReward()
Владелец контракта забирает свою долю комиссии, оплаченную заявителем

* Метод возможен только для заявок в статусе `APPROVED` и `REJECTED`
* Метод доступен только для заявок имеющих флаг `EXECUTED`
* В зависимости от выбранной валюты, на адрес, указанный владельцем контракта, перечисляются либо ETH либо GALT

## Интерфейс для заявителя
#### #submitClaim()
Заявитель подает заявку на возмещение ущерба

* Статус заявки устанавливается в SUBMITTED
* К заявке прилагаются IPFS хеши документов
* Указывается сумма претензии в ETH
* Указывается краткий сопроводительный текст
* Оплачивается комиссия в ETH или GALT

#### #attachDocuments()
Заявитель дополняет существующий набор документов новыми, напр. по просьбе валидатора

* Статус заявки устанавливается в SUBMITTED
* Прилагаются 1 или более IPFS хешей документов
* Статус заявки не меняется

#### #resubmitClaim()
Заявитель повторно подает заявку на возмещение ущерба

* Метод доступен для заявок со статусом SUBMITTED
* Заново указываются:
    * IPFS хеши документов (существующие хеши перезаписываются)
    * сумма претензии в ETH (может отличаться от первоначальной)
    * Указывается краткий сопроводительный текст
* Комиссия повторно не оплачивается

* По каждому валидатору удаляются данные из
 (validator_address => struct Proposal{status: ..., payload: ...})
* Обнуляется массив адресов подавших предожения валидаторов validator_address[] 

## Интерфейс для валидаторов
#### #lock()
Валидатор блокирует за собой право на рассмотрение заявки

* Метод доступен только для заявок в статусе SUBMITTED
* Метод доступен, пока не достигнуто заблокировано M мест для работы над заявкой
* Статус заявки не меняется
* Отказаться от работы над заявкой нельзя
* Статус роли переходит в LOCKED

#### #sendMessage()
Валидатор регистрирует обращение к заявителю, напр. запрос дополнительных данных

* Метод доступен только для заявок в статусе SUBMITTED
* Запорсить данные может только валидатор в статусе LOCKED
* Статус заявки не меняется
* Статус роли не меняется

#### #proposeApproval()
Любой валидатор может предложить одобрить заявку, указав, с кого и сколько будет списано репутации

* Возможен только для заявок SUBMITTED
* Возможен только для ролей в статусе LOCKED
* Один валидатор может предложить только одно действие - `APPROVE`, `REJECT` или `REVERT`
* В качестве параметров ожидаются 3 массива:
  * Адреса валидаторов для штрафа
  * Соответствующие валидаторам роли
  * Соответствующие адресам и ролям штрафы
* Информация о штрафах записывается одним действием, поэтому максимальный объем адресов для штрафа ограничен
 размером блока сети.
* Валидатор, который предлагает данное решение автоматически
 отдает свой голос за него
* Статусы роли и заявки не меняются

* Предложения хранятся в mapping(validator_address => struct Proposal{status: ..., payload: ...})
* Адреса валидаторов, создавших предложения кешируются в массиве validator_address[]

#### #proposeReject()
* Возможен только для заявок SUBMITTED
* Возможен только для ролей в статусе LOCKED
* Один валидатор может предложить только одно действие - `APPROVE`, `REJECT` или `REVERT`
* Прилагается строка с пояснением причины отказа
* Валидатор, который предлагает данное решение автоматически отдает свой голос за него
* Статусы роли и заявки не меняются

#### #proposeRevert()
* Возможен только для заявок SUBMITTED
* Возможен только для ролей в статусе LOCKED
* Один валидатор может предложить только одно действие - `APPROVE`, `REJECT` или `REVERT`
* Прилагается строка с пояснением причины возврата на доработку и реккомендациями по исправлению данных
* Валидатор, который предлагает данное решение автоматически отдает свой голос за него
* Статусы роли и заявки не меняются

#### #vote()
Валидатор голосует за какое-либо из предложений

* Метод доступен только для заявок в статусе SUBMITTED
* Метод доступен только для предложений в статусе SUBMITTED
* Метод доступен только для валидаторов в статусе LOCKED
* Один валидатор может проголосовать только за одно предложение
* Валидатор может переголосовать за другое решение, в таком случае его голос отнимается
 с предыдущего
* Если достигнуто N of M голосов, соответствующе меняется статус заявки
* Голосование останавливается.

#### #claimValidatorReward()
Валидатор забирает свое вознаграждение

* Метод доступен только для заявок в статусе `APPROVED` и `REVERTED`
* Для статуса `APPROVED` `EXECUTED`
* В зависимости от типа заявки, на адрес валидатора перечисляются либо ETH либо GALT
* Поставляется флаг, что валидатор на данной роли получил вознаграждение
* Статус заявки не изменяется

## Предложения
Заявка может перейти в каждый из нижеописанных статусов при достижении N of M голосов

### Approve
При переходе в статус APPROVED автоматически производится списание репутации валидаторов.
Валидаторы обязаны так же выполнить соответствующую транзакцию с multisig кошелька.
Валидаторы могут забать свои вознаграждения.

### Reject
Работа по отклоненной валидаторами заявке не может быть продолжена. Приме - мошенническая претензия.
 Валидаторы могут забрать свое вознаграждение.

### Revert
Работа по отданной на доработку заявке может быть продолжена после повторной подаче.
Пример - валидаторы не согласны по поводу предложенной заявителем суммы компенсации и просят его установить другую.

## Сценарии

### Сценарий 1. Покупатель не может воспользоваться приобретенным участком 

1. Покупатель создает претензию на возмещения ему суммы, потраченной на покупку участка
2. 7 Валидаторов блокируют за собой право работы над заявкой
3. Валидатор #3 предлагает отклонить заявку
4. Валидатор #4 предлагает удовлетворить заявку
5. Валидатор #5 делает свое педложения по утверджению заявки, но с другими парами адрес-роль для списания.
 Данные о предложении записываются в заявку аналогично предыдущему пункту.Параллельно ведутся голосования валидаторов по уже созданным заявкам.
6. Предложени #3 отклонить заявку набирает 2 из 7 голосов
7. Предложени #4 удовлетворить заявку набирает 4 из 7 голосов
8. Предложени #5 удовлетворить заявку набирает 1 из 7 голосов
9. Один из проголосовавших за предложение #3 меняет свое решение и голосует за предложение #4
10. т.к. предложение #4 набирает необходимое количество голосов 5 из 7, заявка переходит в статус APPROVED
11. Последний проголосовавший за принятое предложение оплачивает расходы по транзакции списания средств
12. Валидаторы создают аналогичное предложение в MultiSig хранящем GALT, голосуют в соответствии с принятым решением, компенсация
в GALT переводится на адрес, подавший заявку
13. Валидаторы, чьи депозиты уменьшились ниже необходимого уровня, становятся не активными
14. Ставшие не активными валидаторы, которые хотят продолжить работу над заявками, пополняют свои депозиты
и становятся активным